合批是性能优化的一项技术，旨在减少渲染过程终的绘制调用（DrawCalls）次数，从而提高渲染性能。
## 什么是合批
在unity中，将多个物体的渲染请求合并成一个更少的绘制调用，这样就可以在一次GPU调用中渲染多个物体，而不是每个物体单独触发一个绘制调用。
## 为什么要合批
+ 减少状态切换   
  在DrawCall调用时，如果材质或者着色器等发生变化，GPU需要切换不同的渲染状态，切换渲染状态会带来性能损失。
+ 减少DrawCall
  + CPU向GPU发出绘制调用指令，传输数据。每次绘制调用都会带来一定的cpu开销和gpu开销。
  + 合批将多个物体合并为一次绘制调用，减少了绘制调用次数，进而提高性能。
+ 减少数据传输
  + 允许多个物体共享网格数据，减少重复的顶点数据传输
  + 材质持久化在GPU内存中，内容不改变，就不需要设置和upload缓冲区
## Unity合批方法
### SRP Batcher
适用的情景：场景使用大量不同材质但很少着色器变体的情况。   
技术原理：材质数据持久化在GPU内存中(CBuffers)。如果材质内容不改变，就不需要设置和upload缓冲区。CPU只是处理内置引擎属性，物体的变换矩阵。   
性能提升：   
  + 每个材质的内容都持久化存储在GPU内存中，内容不变不需要设置缓冲区。
  + 专属的代码管理“per object”在一块大GPU内存中。
       
标准SRP与SRP Batcher对比：   
+ 标准的srp渲染循环中，材质不变的情况下，一个批次的工作包括：收集系统内置数据 Object数据上传到CBuffer, 收集材质数据上传到CBuffer。绑定材质buffer, Object buffer。调用DrawCall.    
+ srp batcher循环中，shader变体不改变的情况下，一个批次的工作是：绑定持久化材质CBuffer  绑定object在larget CBuffer中的偏移。调用DrawCall    
![image](https://github.com/user-attachments/assets/d540e059-8a8a-4e94-ad69-2dc3757ce89e)

影响性能的SetShaderPass，在标准的SRP中，每个新材质都触发调用。在SRP Batcher中，每个新的shader变体触发调用。所以为了最大优化性能，保持batchers尽可能大。可以大量使用相同shader、材质属性不同的材质，尽可能避免shader变体的改变。
### GUP Instancing
适用情景：渲染大量相同的或者相似的物体。如场景中树木，建筑、草丛、粒子。相同网格数据，相同材质。   
技术原理：将多个物体的渲染合并为一次批量绘制调用，避免了重复的绘制调用和相同数据的多次传输。   
如何带来性能提升：   
  + 数据方面：
    * 共享数据：所有实例使用相同的顶点缓冲区和索引缓冲区来描述几何形状
    * 实例化数据：每个实例有自己的变换矩阵、颜色等属性。这些数据会通过额外的实例化缓冲区传递到gpu中。
  + 渲染管线中的处理：
    * GPU在渲染时，会处理实例化数据，讲这些数据传递给顶点着色器，每个实例的变换和属性会在GPU上并行处理
    * 顶点着色器会根据实例数据来计算每个实例的位置、方向、缩放等
    * 然后GPU并行处理所有实例，逐个执行它们的着色和渲染
### 动态批处理
+ 运行时，对可见对象进行动态合批
+ 网格对象使用同一个材质引用
+ 顶点属性数量限制，900个顶点属性（float4)
### 静态批处理
+ 编译期标记，运行时，对可见对象进行合批，复制网格数据到同一块大的顶点缓存区，如果网格存在多个实例，会有多个副本数据
+ 网格对象使用同一材质引用
+ 对非运动物体起作用，对运行期动态创建具有static标记的对象，引擎不会自动识别进行合批。
